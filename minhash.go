package comparator

import (
	"bytes"
	"encoding/binary"
	"errors"

	"github.com/AlasdairF/Tokenize"
	"github.com/dgryski/go-farm"
	"github.com/dgryski/go-minhash"
	"github.com/dgryski/go-spooky"
)

var (
	// ErrSigLengthInvalid returned by Compare when slices are wrong or unequal lengths.
	ErrSigLengthInvalid = errors.New("Signature byte slice length invalid, or compared slice length mismatch")
)

// MinhashComparator implements the Comparator interface using Minhash with a
// signature length of 250 and the Spooky and Farmhash 64-bit hash functions.
type MinhashComparator struct {
	// Threshold is the similarity level above which the MinhashComparator.Same
	// method will return true for two signatures or documents.
	Threshold float64
}

// NewMinhashComparator creates a comparator with the given threshold similarity.
func NewMinhashComparator(threshold float64) Comparator {
	return &MinhashComparator{Threshold: threshold}
}

func (mh MinhashComparator) newMinhash() *minhash.MinWise {
	return minhash.NewMinWise(farm.Hash64, spooky.Hash64, 250)
}

// Signature for a document. This may be quite large depending on settings,
// as it is a little-endian serialisation of the []uint64 array returned
// by the underlying Minhash algorithm.
func (mh MinhashComparator) Signature(document string) []byte {
	hasher := mh.newMinhash()
	// lowercase = true,
	// stripAccents = false,
	// stripContractions = true,
	// stripNumbers = true,
	// stripForeign = false
	tokenize.AllInOne([]byte(document), hasher.Push, true, false, true, true, false)
	bigsig := hasher.Signature()
	output := make([]byte, 0, len(bigsig)*8)
	buf := new(bytes.Buffer)
	for _, s := range bigsig {
		err := binary.Write(buf, binary.LittleEndian, s)
		if err != nil {
			panic(err)
		}
		output = append(output, buf.Bytes()...)
		buf.Reset()
	}
	return output
}

// Compare two signatures as generated by the above. Answer will lie between 0,1
func (mh MinhashComparator) Compare(sig1, sig2 []byte) (float64, error) {
	if len(sig1) == 0 {
		return 0, ErrSigLengthInvalid
	}
	if len(sig1) != len(sig2) {
		return 0, ErrSigLengthInvalid
	}
	if len(sig1)%8 != 0 || len(sig2)%8 != 0 {
		return 0, ErrSigLengthInvalid
	}
	// Decode signatures to uint64s and compare matches/length, as Minhash does.
	matches := 0
	for i := 0; i < len(sig1); i += 8 {
		v1 := binary.LittleEndian.Uint64(sig1[i : i+8])
		v2 := binary.LittleEndian.Uint64(sig2[i : i+8])
		if v1 == v2 {
			matches++
		}
	}
	if matches == 0 {
		return 0, nil
	}
	return float64(matches) / float64(len(sig1)/8), nil
}

// Similarity from 0-1 of two raw document strings.
func (mh MinhashComparator) Similarity(document1, document2 string) float64 {
	sim, err := mh.Compare(mh.Signature(document1), mh.Signature(document2))
	if err != nil {
		panic(err)
	}
	return sim
}

// Same - Are similarities above the set Threshold for this MinhashCompraator?
func (mh MinhashComparator) Same(document1, document2 string) bool {
	return mh.Threshold < mh.Similarity(document1, document2)
}
